<!doctype html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Functions | Toolbox/Package</title>
		<link rel="stylesheet" type="text/css" href="styles.css">
	</head>
	<body>
		<header>
			<a href=".">go-sqlite</a>
		</header>
		<nav>
			<a href=".">index</a>
			<a href="LICENSE.html">License</a>
			<a href="README.html">Readme</a>
			<a href="Functions.html" class="active">Functions</a>
			<a href="Datastructure.html">Datastructure</a>
			<a href="Download.html">Download</a>
		</nav>
		<article>
<h1>Functions</h1>
<h2>Available functions</h2>
<ul>
<li>
sqlite
</li><li>
sqlite<em>properties
</li><li>
save
</li><li>
load
</li><li>
fprintf
</li><li>
fread
</li><li>
fwrite
</li><li>
runsqlscript
</li><li>
sqldump
</li><li>
insert
</li><li>
tables
</li>
</ul>
<h2>Open a sqlite session</h2>
<p>It doesn't matter if the file exist or not.</p>
<code><pre>
>> s=sqlite('new.db');
</pre></code>
<h2>fprintf</h2>
<p><code>[status, output]=fprintf(obj, string, value)</code></p>
<p>Add a new table called <code>table1</code> with 3 TEXT columns</p>
<p>fprintf has always two output arguments. If the first output is 0, everything is fine.</p>
<code><pre>
>> [status,output]=fprintf(s,'create table table1 (id INTEGER PRIMARY KEY, Name TEXT, Animal TEXT, Job TEXT)')
status =                    0
output =

>> [status,output]=fprintf(s,'.tables')
status =                    0
output = table1
</pre></code>
<p>Add some values to <code>table1</code></p>
<code><pre>
>> fprintf(s,'insert into table1 (Name, Animal, Job) values (''Chris'',''Cat'',''Clown'')');
</pre></code>
<p>You can use one variable for parsing into your string. The variable can be a string or a double number. But it's important that you mark the place in both case  with <strong>%s</strong>.</p>
<code><pre>
>> str='(''Alf'',''Ape'',''Astronaut'')'
str = ('Alf','Ape','Astronaut')
>> fprintf(s,'insert into table1 (Name, Animal, Job) values %s',str);
</pre></code>
<p><code>table1</code> looks now like that.</p>
<code><pre>
>> [~,out]=fprintf (s,'select * from table1')
out = 1|Chris|Cat|Clown
2|Alf|Ape|Astronaut
</pre></code>
<h4>fread,fwrite,fprintf</h4>
<p>This three functions do the same, except for the number of outputs.</p>
<p><code>[status,output]=fprintf(...)</code> answer is status and output.</p>
<p><code>[output]=fread(...)</code> answer is only the output.</p>
<p><code>[status]=fwrite(...)</code> answer is only the status.</p>
<p>Example:</p>
<code><pre>
>> [status,output]=fprintf(s,'pragma table_info(table1)')
status =                    0
output = 0|id|INTEGER|0||1
1|Name|TEXT|0||0
2|Animal|TEXT|0||0
3|Job|TEXT|0||0

>> fread(s,'pragma table_info(table1)')
ans = 0|id|INTEGER|0||1
1|Name|TEXT|0||0
2|Animal|TEXT|0||0
3|Job|TEXT|0||0

>> fwrite(s,'pragma table_info(table1)')
ans =                    0
</pre></code>
<h2>save</h2>
<p><code>save(obj, data)</code>   <code>save(obj, 'table_name', data)</code></p>
<p><code>save</code> stores the most of your workspace <em>(depends on choosen go-sqlite mode)</em> automatically for you.    The matrix will be reshaped to a one column matrix. The reshape information <em>(number of rows)</em> is stored at the first place <em>(id=1)</em>.  </p>
<p>The column Name for the matrix value is <code>go_sqlite</code>, the datatype is <code>REAL</code>. </p>
<code><pre>
>> m=rand(5,5);
>> save(s,'mytable',m) % will save variable 'm' in tablename 'mytable'
>> save(s,m) % will save variable 'm' in tablename 'm'
>> fread(s,'pragma table_info(mytable)')
ans = 0|id|INTEGER|0||1
1|Value|REAL|0||0
</pre></code>
<h2>load</h2>
<p><code>load(obj, tablename)</code>   <code>out=load(obj, tablename)</code></p>
<p><code>load</code> can read a table which is written by <code>save</code>. It's more or less auto deteced. </p>
<code><pre>
>> load(s,'m'); % will assign table 'm' as variablename 'm' to the workspace
>> n=load(s,'m'); 
>> load(s) % this will load all tables from the database to the workspace
</pre></code>
<p>If the typical table structure is not found, it will read the table into one cell.</p>
<code><pre>
>> cell=load(s,'table1')
cell =
{
  [1,1] = 1
  [2,1] = 2
  [1,2] = Chris
  [2,2] = Alf
  [1,3] = Cat
  [2,3] = Ape
  [1,4] = Clown
  [2,4] = Astronaut
}
</pre></code>
<p>Happy parsing :)</p>
<h4>runsqlscript</h4>
<p><code>runsqlscript(obj, inputfile)</code></p>
<p>You can simply apply sql scripts to your database like that</p>
<code><pre>
>> status = runsqlscript(s,'../sqlitescript.sql' );
</pre></code>
<h2>sqldump</h2>
<p><code>sqldump(obj, outputfile)</code></p>
<p>You can simply dump (export) your sqlite database as sql file.</p>
<code><pre>
>> status = sqldump(s,'dump.sql');
</pre></code>
<h2>insert</h2>
<p><code>insert(obj, table, column, data)</code></p>
<p>Simple insert function as find in matlab database toolbox.   table and column should be strings. data can be a string or double.</p>
<h2>tables</h2>
<p><code>[parsed, unparsed]=tables(obj)</code></p>
<p>List all available talbes in the database.</p>
<code><pre>
octave:3> tables(s)
ans = 
{
  [1,1] = m.km 
  [1,2] = m.points 
  [1,3] = matrix 
  [1,4] = table1 
}
octave:4> [~,raw]=tables(s)
raw = m.km       m.points   matrix     table1     usernames
</pre></code>
<h2>sqlite<em>properties</h2>
<p><code>s=sqlite_properties(s, varargin)</code></p>
<p>sqlite<em>properties allows you to display or change class properties.   To simply display the properties, do:  </p>
<code><pre>
>> sqlite_properties(s)
sqlite path: sqlite3
sqlite file: wow2
go-sqlite mode: ego
go-sqlite prec: 16
</pre></code>
<p>To simply chang properties, simply name your changes.</p>
<code><pre>
>> s=sqlite_properties(s,'mode','ego','prec',12,'file','test.db')
s = &lt;class sqlite>
>> sqlite_properties(s)
sqlite path: sqlite3
sqlite file: test.db
go-sqlite mode: ego
go-sqlite prec: 12
</pre></code>
<h1>Performance</h1>
<p>Writing is slow if your database file is located on a hard disk (hdd). Furthermore, if you're using <code>save</code> commands, go-sqlite can write max. 100 values at  ones <em>(e.g. it do 3 writes for a 15x10 matrx. 1st write is the dimension, 2nd write the first 100 values and the 3rd write are the last 50 values)</em>. This is  the disadvantage of using the sqlite3 binary.     Reading is much faster than writing.  </p>
<p>On Linux, you can locate your database file to tmpfs. It's probably the fastest methode.   How ever, on modern hosts with SSD storage, if's fairly fast too.</p>
<p>If it's even to slow for your needs, try another database, e.g. redis with <a href="https://github.com/markuman/go-redis">go-redis</a>.</p>

		</article>
	</body>
</html>
